package mbr

import (
	"testing"
	"bytes"
)

/*
(parted) print
Model: Msft Virtual Disk (scsi)
Disk /dev/sda: 41943040s
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start      End        Size       Type     File system     Flags
 1      2048s      39895039s  39892992s  primary  xfs             boot
 2      39895040s  41943039s  2048000s   primary  linux-swap(v1)
 */
var mbrDump1 = []byte{0xeb, 0x63, 0x90, 0x10, 0x8e, 0xd0, 0xbc, 0x0, 0xb0, 0xb8, 0x0, 0x0, 0x8e, 0xd8, 0x8e, 0xc0, 0xfb, 0xbe, 0x0, 0x7c, 0xbf, 0x0, 0x6, 0xb9, 0x0, 0x2, 0xf3, 0xa4, 0xea, 0x21, 0x6, 0x0, 0x0, 0xbe, 0xbe, 0x7, 0x38, 0x4, 0x75, 0xb, 0x83, 0xc6, 0x10, 0x81, 0xfe, 0xfe, 0x7, 0x75, 0xf3, 0xeb, 0x16, 0xb4, 0x2, 0xb0, 0x1, 0xbb, 0x0, 0x7c, 0xb2, 0x80, 0x8a, 0x74, 0x1, 0x8b, 0x4c, 0x2, 0xcd, 0x13, 0xea, 0x0, 0x7c, 0x0, 0x0, 0xeb, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xfa, 0x90, 0x90, 0xf6, 0xc2, 0x80, 0x74, 0x5, 0xf6, 0xc2, 0x70, 0x74, 0x2, 0xb2, 0x80, 0xea, 0x79, 0x7c, 0x0, 0x0, 0x31, 0xc0, 0x8e, 0xd8, 0x8e, 0xd0, 0xbc, 0x0, 0x20, 0xfb, 0xa0, 0x64, 0x7c, 0x3c, 0xff, 0x74, 0x2, 0x88, 0xc2, 0x52, 0xbe, 0x5, 0x7c, 0xb4, 0x41, 0xbb, 0xaa, 0x55, 0xcd, 0x13, 0x5a, 0x52, 0x72, 0x3d, 0x81, 0xfb, 0x55, 0xaa, 0x75, 0x37, 0x83, 0xe1, 0x1, 0x74, 0x32, 0x31, 0xc0, 0x89, 0x44, 0x4, 0x40, 0x88, 0x44, 0xff, 0x89, 0x44, 0x2, 0xc7, 0x4, 0x10, 0x0, 0x66, 0x8b, 0x1e, 0x5c, 0x7c, 0x66, 0x89, 0x5c, 0x8, 0x66, 0x8b, 0x1e, 0x60, 0x7c, 0x66, 0x89, 0x5c, 0xc, 0xc7, 0x44, 0x6, 0x0, 0x70, 0xb4, 0x42, 0xcd, 0x13, 0x72, 0x5, 0xbb, 0x0, 0x70, 0xeb, 0x76, 0xb4, 0x8, 0xcd, 0x13, 0x73, 0xd, 0x5a, 0x84, 0xd2, 0xf, 0x83, 0xde, 0x0, 0xbe, 0x85, 0x7d, 0xe9, 0x82, 0x0, 0x66, 0xf, 0xb6, 0xc6, 0x88, 0x64, 0xff, 0x40, 0x66, 0x89, 0x44, 0x4, 0xf, 0xb6, 0xd1, 0xc1, 0xe2, 0x2, 0x88, 0xe8, 0x88, 0xf4, 0x40, 0x89, 0x44, 0x8, 0xf, 0xb6, 0xc2, 0xc0, 0xe8, 0x2, 0x66, 0x89, 0x4, 0x66, 0xa1, 0x60, 0x7c, 0x66, 0x9, 0xc0, 0x75, 0x4e, 0x66, 0xa1, 0x5c, 0x7c, 0x66, 0x31, 0xd2, 0x66, 0xf7, 0x34, 0x88, 0xd1, 0x31, 0xd2, 0x66, 0xf7, 0x74, 0x4, 0x3b, 0x44, 0x8, 0x7d, 0x37, 0xfe, 0xc1, 0x88, 0xc5, 0x30, 0xc0, 0xc1, 0xe8, 0x2, 0x8, 0xc1, 0x88, 0xd0, 0x5a, 0x88, 0xc6, 0xbb, 0x0, 0x70, 0x8e, 0xc3, 0x31, 0xdb, 0xb8, 0x1, 0x2, 0xcd, 0x13, 0x72, 0x1e, 0x8c, 0xc3, 0x60, 0x1e, 0xb9, 0x0, 0x1, 0x8e, 0xdb, 0x31, 0xf6, 0xbf, 0x0, 0x80, 0x8e, 0xc6, 0xfc, 0xf3, 0xa5, 0x1f, 0x61, 0xff, 0x26, 0x5a, 0x7c, 0xbe, 0x80, 0x7d, 0xeb, 0x3, 0xbe, 0x8f, 0x7d, 0xe8, 0x34, 0x0, 0xbe, 0x94, 0x7d, 0xe8, 0x2e, 0x0, 0xcd, 0x18, 0xeb, 0xfe, 0x47, 0x52, 0x55, 0x42, 0x20, 0x0, 0x47, 0x65, 0x6f, 0x6d, 0x0, 0x48, 0x61, 0x72, 0x64, 0x20, 0x44, 0x69, 0x73, 0x6b, 0x0, 0x52, 0x65, 0x61, 0x64, 0x0, 0x20, 0x45, 0x72, 0x72, 0x6f, 0x72, 0xd, 0xa, 0x0, 0xbb, 0x1, 0x0, 0xb4, 0xe, 0xcd, 0x10, 0xac, 0x3c, 0x0, 0x75, 0xf4, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb2, 0x3d, 0xe, 0x0, 0x0, 0x0, 0x80, 0x20, 0x21, 0x0, 0x83, 0xfe, 0xff, 0xff, 0x0, 0x8, 0x0, 0x0, 0x0, 0xb8, 0x60, 0x2, 0x0, 0xfe, 0xff, 0xff, 0x82, 0xfe, 0xff, 0xff, 0x0, 0xc0, 0x60, 0x2, 0x0, 0x40, 0x1f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0xaa}

func Test_writeLittleEndianUINT32(t *testing.T){
	buf := make([]byte, 4)
	writeLittleEndianUINT32(buf, 67305985)
	if buf[0] != 1 || buf[1] != 2 || buf[2] != 3 || buf[3] != 4{
		t.Error("Error")
	}
}

func Test_readLittleEndianUINT32(t *testing.T){
	buf := []byte{1,2,3,4}
	if readLittleEndianUINT32(buf) != 67305985 {
		t.Error("Error")
	}
}

func Test_fixSignature(t *testing.T){
	if mbrSignOffset != 510 {
		t.Error("MBR Offset error")
	}

	buf := bytes.NewReader(make([]byte, 512))
	mbr, _ := Read(buf)
	mbr.FixSignature()
	if mbr.bytes[mbrSignOffset] != 0x55 || mbr.bytes[mbrSignOffset+1] != 0xAA {
		t.Error("Error")
	}
}

func Test_readGoodMBR(t *testing.T){
	buf := bytes.NewReader(mbrDump1)
	mbr, err := Read(buf)
	if err != nil {
		t.Error("Can't read: " + err.Error())
	}
	if !mbr.GetPartition(1).IsBootable() {
		t.Error("partition 1 not bootable")
	}
	if mbr.GetPartition(1).IsEmpty() {
		t.Error("partition 1 not empty")
	}
	if mbr.GetPartition(1).GetLBAStart() != 2048 {
		t.Errorf("LBA start in partition 1: %d", mbr.GetPartition(1).GetLBAStart() )
	}
	if mbr.GetPartition(1).GetLBALen() != 39892992 {
		t.Errorf("LBA length in partition 1: %d", mbr.GetPartition(1).GetLBALen() )
	}
	if mbr.GetPartition(2).IsBootable() {
		t.Error("partition 2 is bootable")
	}
	if mbr.GetPartition(2).IsEmpty() {
		t.Error("partition 2 not empty")
	}
	if mbr.GetPartition(2).GetLBAStart() != 39895040 {
		t.Errorf("LBA start in partition 2: %d", mbr.GetPartition(2).GetLBAStart() )
	}
	if mbr.GetPartition(2).GetLBALen() != 2048000 {
		t.Errorf("LBA length in partition 2: %d", mbr.GetPartition(2).GetLBALen() )
	}
	if !mbr.GetPartition(3).IsEmpty() {
		t.Error("partition 3 empty")
	}
	if !mbr.GetPartition(4).IsEmpty() {
		t.Error("partition 3 empty")
	}
}

func Test_fixPartitionSize(t *testing.T){
	buf := bytes.NewReader(mbrDump1)
	mbr, _ := Read(buf)
	mbr.GetPartition(2).SetLBALen(20)
	out := bytes.NewBuffer(nil)
	mbr.Write(out)

	need := make([]byte, 512)
	copy(need, mbrDump1)

	need[474] = 20 // 446 + 16 + 12
	need[475] = 0  // 446 + 16 + 13
	need[476] = 0  // 446 + 16 + 14
	need[477] = 0  // 446 + 16 + 15

	outBytes := out.Bytes()
	for i := 0; i < 512; i++{
		if need[i] != outBytes[i] {
			t.Errorf("Bad value in byte: %v (%v != %v)", i, need[i], outBytes[i])
		}
	}
}

func Test_fixPartitionStart(t *testing.T){
	buf := bytes.NewReader(mbrDump1)
	mbr, _ := Read(buf)
	mbr.GetPartition(1).SetLBAStart(20)
	out := bytes.NewBuffer(nil)
	mbr.Write(out)

	need := make([]byte, 512)
	copy(need, mbrDump1)


	need[454] = 20 // 446 + 8
	need[455] = 0 //  446 +  9
	need[456] = 0 //  446 + 10
	need[457] = 0 //  446 + 11

	outBytes := out.Bytes()
	for i := 0; i < 512; i++{
		if need[i] != outBytes[i] {
			t.Errorf("Bad value in byte: %d (%d != %d)", i, need[i], outBytes[i])
		}
	}
}

func Test_MakeProtective(t *testing.T) {
	for _, d := range []struct {
		ssize    int
		diskSize uint64
		expected uint32
		desc     string
	}{
		{512, 21474836480, 41943039, "20G x 512"},
		{512, 4398046511104, 0xFFFFFFFF, "4TiB x 512"},
		{4096, 1024209543168, 250051157, "1TB x 4k"},
		{4096, 17592186044416, 0xFFFFFFFF, "16TiB x 4k"},
	} {
		buf := bytes.NewReader(mbrDump1)
		mbr, _ := Read(buf)
		mbr.MakeProtective(d.ssize, d.diskSize)
		if err := mbr.Check(); err != nil {
			t.Errorf("ProtectiveMBR failed check: %s", err)
		}

		pt := mbr.GetPartition(1)
		if pt.GetType() != PART_GPT {
			t.Errorf("%s Partition 1 had type != PART_GPT", d.desc)
		}

		if found := pt.GetLBAStart(); found != 1 {
			t.Errorf("%s Partition 1 start at %d expected 1", d.desc, found)
		}

		if found := pt.GetLBALen(); found != d.expected {
			t.Errorf("%s Partition 1 had len %d, expected %d", d.desc, found, d.expected)
		}
		for n := 2; n <= 4; n++ {
			if mbr.GetPartition(n).GetType() != PART_EMPTY {
				t.Errorf("Partition %d was not empty", n)
			}
		}
	}

}
